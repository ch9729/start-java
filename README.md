# 자바 입문

## 1일차

- 산술 연산자
    - + , - , * , / , %
        - int 형끼리 계산하면 계산 결과도 같은 int 형을 사용한다. int형은 정수이기 때문에 소수점 이하를 포함할 수 없다.
        - 문자열과 숫자를 더하면 숫자를 문자열로 변경한다.
        - 변수에 담겨 있어도 문자와 숫자를 더하면 문자가 된다.
        - 연산자 우선순위를 변경하려면 수학과 마찬가지로 괄호()를 사용한다. ()를 사용한 곳이 먼저 계산된다.

- 증감 연산자
    - ++, --로 표현되며, 이들은 변수의 값을 1만큼 증가시키거나 감소시킨다.
        - a = a + 1을 ++a로 간단히 표현할 수 있는 것이 증감 연산자이다.
        - a = a - 1을 --a로 간단히 표현할 수 있는 것이 감소 연산자이다.

    - 전위, 후의 증감연산자
        - ++a: 증감 연산자를 피연산자 앞에 둘 수 있다.
            - b = ++a은 a의 값을 먼저 증가 시키고 그 결과를 b에 대입
            - a = 2, b = 2

    - --a: 증감 연산자를 피연산자 뒤에 둘 수 있다.
        - b = a++은 a의 현재 값을 b에 먼저 대입하고, 그 후 a값을 증가시킴
        - a = 2, b = 1

- 비교 연산자
    - 두 값을 비교 할때 사용한다. 주로 조건문과 함께 사용한다.
    - =, ==은 다르다.
    - 문자열 비교
        - 문자열을 비교 할때는 ==이 아닌 .equals()로 사용한다.

- 논리 연산자
    - boolean형인 true, false를 비교하는데 사용한다.
        - &&(그리고) : 모두 참이면 참을 반환, 둘중 하나라도 거짓이면 거짓을 반환
        - ||(또는) : 하나라도 참이면 참을 반환, 둘다 거짓이면 거짓을 반환
        - !(부정) : 참이면 거짓을, 거짓이면 참을 반환

- 대입 연산자
    - 값을 변수에 할당하는 연산자
    - += , -= , *= , /= , %=
        - i = i + 3 => i += 3
- 삼항 연산자
  - if문을 사용할 때 단순히 참과 거짓에 따라 특정 값을 구하는 경우 삼항 연산자라고 불리는 ?: 연산자를 사용
    - (조건) ? 참_표현식 : 거짓_표현식
## 2일차

### 조건문
- if문
  - if문은 특정 조건이 참인지 확인하고, 그 조건이 참(true)일 경우 특정 코드 블록 실행
  - else문은 if문에서 만족하는 조건이 없을때 실행하는 코드를 제공한다. 
    - 전체 if 문을 하나로 묶는것. 특정 조건이 만족하면 해당 코드를 실행하고 if문 전체를 빠져 나온다.

- switch문
  - 단순히 값이 같은지만 비교 가능
  - 조건식의 결과 값이 어떤 case의 값과 일치하면 해당 case 코드가 실행된다.
  - break문은 현재 실행 중인 코드를 끝내고 switch문을 빠져 나온다.
  - default는 조건식의 결과값이 모든 case의 값과 일치하지 않을때 실행된다.

### 반복문
- 특정 코드를 반복해서 실행할 때 사용
- break와 continue는 반복문에서 사용할수 있는 키워드
- break는 반복문을 즉시 종료하고 나간다.
- continue는 반복문의 나머지 부분을 건너뛰고 다음 반복으로 진행하는데 사용된다.
- while
  - 조건식을 확인하고 참이면 코드 블럭을 실행하고 거짓이면 while문을 벗어난다.
  - 조건식이 참이면 코드 블럭을 실행한다. 이후 코드 블럭이 끝나면 다시 조건식 검사로 돌아가서 조건식을 검사한다.
  - do-while문은 최초 한번은 항상 실행된다. 주로 최초 한번은 코드 블럭을 꼭 실행해야 하는 경우에 사용하면 된다.
- for
  - 주로 반복 횟수가 정해져 있을 때 사용한다.

## 3일차
- 지역 변수
  - 본인의 코드 블록 안에서만 생존한다.
  - 자신의 코드 블록 안에서는 얼마든지 접근할수 있다. 하지만 자신의 코드 블록을 벗어나면 제거되기 때문에 접근할수 없다.
  - scope 존재 이유
    - 비효율적인 메모리 사용
    - 코드 복잡성 증가
  - 변수는 꼭 필요한 범위로 한정해서 사용하는 것이 좋다.

- 형 변환
  - 작은 범위에서 큰 범위로는 값을 넣을수 있다.
  -  큰 범위에서 작은 범위는 문제가 발생한다.
    - 소수점 버림
    - 오버플로우
  - int -> long -> double
  - 자동 형변환
    - 작은 범위 숫자 타입에서 큰 범위 숫자 타입으로의 대입은 직접 형변환을 하지 않아도 된다.
    - 자동 형변환, 또는 묵시적 형변환이라 한다.
  - 명시적 형변환
    - 큰 범위에서 작은 범위 대입은 명시적 형변환이 필요
    - 숫자가 손실되는 문제가 발생
    - 기존 범위를 초과해서 표현하게 되면 전혀 다른 숫자가 표현 되는데 이를 오버플로우라고 한다.
    - 오버플로우가 발생하는 것 자체가 문제!!!!
    - 오버플로우 자체가 발생하지 않도록 막아야 한다.
  - 같은 타입끼리의 계산은 같은 타입의 결과를 낸다.
  - 서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.